---
title: "Mapeamento digital do solo para agricultura de precisão"
subtitle: "FEAGRI-UNICAMP"
author: "Alessandro Samuel-Rosa"
date: "25 e 26 de janeiro de 2019"
output: bookdown::html_document2
lang: pt
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(magrittr)
library(dplyr)
library(sf)
library(raster)
library(mapview)
mapviewOptions(basemaps = "Esri.WorldImagery")
library(RSAGA)
library(mapedit)
library(fields)
library(googlesheets)
library(readr)
library(pedometrics)
library(caret)
```

Este estudo tem como objetivo realizar o mapeamento de uma série de propriedades do solo em uma fazenda de 
produção de bovinos de corte no município de Caiuá, no oeste do estado de São Paulo. Dentre as propriedades do 
solo estão: conteúdo de fósforo e bases trocáveis, capacidade de troca de cátions e saturação por bases, 
conteúdo de micronutrientes, pH e acidez potencial, conteúdo de carbono orgânico, e distribuição do tamanho de
partículas.

# Material e Métodos

## Área de estudo

O primeiro passo consiste em fazer um levantamento das informações disponíveis sobre a área de estudo. Essas 
informações incluem dados espacialmente exaustivos, como imagens de satélite e índices de vegetação, modelos
digitais de elevação e atributos de terreno, mapas pedológicos e geológicos, entre outros. Também incluem 
informações históricas sobre o uso da terra e as práticas de manejo e conservação do solo.

Vamos iniciar visualizando a área de estudo sobre uma imagem de satélite da coleção pública da ESRI. Para isso,
carregamos o arquivo vetorial contendo o limite da área de estudo, `"../data/vector/farm.shp"`, usando a função 
`sf::read_sf`. Em seguida, criamos uma figura responsiva usando a função `mapview::mapview`.

```{r}
farm <- read_sf("../data/vector/farm.shp")
mapviewFarm <- 
  function () {
    mapview(farm, color = "red", alpha.regions = 0.01, legend = FALSE)
  }
mapviewFarm()
```

### Relevo

A imagem acima mostra que a área de estudo é cortada por inúmeros terraços, estruturas construídas para reduzir
a energia cinética da água da chuva escoando na superfície do solo e, assim, reduzir a erosão do solo. Também
observamos algumas escavações para coleta da enxurrada em pontos de convergência do terreno. Como os fluxos 
hídricos na paisagem influenciam a formação do solo, espera-se que o relevo da área de estudo exerça algum
controle sobre a distribuição espacial das propriedades do solo.

Vamos analisar mais de perto o relevo da área de estudo utilizando o modelo digital de elevação (MDE). Para 
isso, primeiro calculamos o sombreamento do relevo usando `sf::gdal_utils`. Em seguida, carregamos os dois
arquivos, `"../data/raster/elevation.tif"` e `"../data/raster/hillshade.tif"`, usando `raster::stack`, para 
então gerar uma imagem com as duas camadas sobrepostas, dando assim a impressão visual do formato 
tridimensional do terreno. Para auxiliar, adicionamos curvas de nível geradas com a função 
`raster::rasterToContour`.

```{r}
gdal_utils(
  util = "demprocessing", source = "../data/raster/elevation.tif", destination = "../data/raster/hillshade.tif",
  processing = "hillshade")
dem <- stack("../data/raster/elevation.tif", "../data/raster/hillshade.tif")
contour_lines <- dem[["elevation"]] %>% rasterToContour() %>% st_as_sf()
plot(dem[["hillshade"]], col = grey(0:100/100), legend = FALSE)
plot(dem[["elevation"]], col = topo.colors(24, alpha = 0.50), add = TRUE)
plot(contour_lines, add = TRUE, col = "black")
```

__Exercício 1__ A imagem acima mostra a configuração do terreno na área de estudo. Você espera que o terreno
esteja relacionado à distribuição espacial das propriedades do solo que se pretende mapear? De que maneira se 
daria essa relação? Quais atributos de terreno podem ser úteis para descrever o efeito do terreno sobre a
distribuição espacial das propriedades do solo? Faça uma lista com, no mínimo, cinco atributos de terreno.

1. ...
2. ...
3. ...
4. ...
5. ...

Atributos de terreno podem ser computados usando o SAGA GIS. Por exemplo, `RSAGA::rsaga.slope.asp.curv` calcula
alguns atributos locais do terreno, como a declividade e a curvatura do terreno. Alguns atributos regionais do
terreno, como a área de captação e o índice de umidade topográfica, podem ser calculados usando 
`RSAGA::rsaga.wetness.index`. Note que o formato de arquivo matricial do SAGA GIS é SGRD -- para escrita -- e
SDAT -- para leitura.

```{r}
rsaga.slope.asp.curv(
  in.dem = "../data/raster/elevation.tif",
  out.slope = "../data/raster/slope.sgrd",
  out.cgene = "../data/raster/general_curvature.sgrd",
  out.cplan = "../data/raster/plan_curvature.sgrd",
  out.cprof = "../data/raster/profile_curvature.sgrd",
  unit.slope = "percent")
rsaga.wetness.index(
  in.dem = "../data/raster/elevation.tif",
  out.wetness.index = "../data/raster/twi.sgrd", 
  out.carea = "../data/raster/catchment_area.sgrd", 
  out.cslope = "../data/raster/catchment_slope.sgrd",
  area.type = "absolute")
```

Em seguida carregamos os atributos de terreno computados usando o SAGA GIS para dentro do objeto `dem` -- 
criado acima -- usando `raster::stack`. Calculamos o logaritmo da área de captação para transformar os dados 
para uma escala mais estreita e interpretável. Ainda, transformamos os valores de declividade da área de 
captação de radianos para porcentagem.

```{r}
dem <-
  stack(
    c("../data/raster/slope.sdat",
    "../data/raster/general_curvature.sdat",
    "../data/raster/plan_curvature.sdat", 
    "../data/raster/profile_curvature.sdat",
    "../data/raster/twi.sdat", 
    "../data/raster/catchment_area.sdat",
    "../data/raster/catchment_slope.sdat")) %>% 
  stack(dem)
dem[["catchment_area"]] <- log1p(dem[["catchment_area"]])
dem[["catchment_slope"]] <- tan(dem[["catchment_slope"]]) * 100
```

Depois de processados, podemos visualizar os atributos do terreno usando o sombreamento e as curvas de nível 
para auxiliar na sua interpretação. Como são vários os atributos do terreno, precisamos iterar sobre a função
`plot` tantas vezes quantos forem os atributos do terreno usando a função `for`.

```{r}
nr <- nlayers(dem) %>% sqrt() %>% ceiling()
nc <- nlayers(dem) / nr
par(mfrow = c(nr, nc))
for (i in nlayers(dem):1) {
  plot(dem[["hillshade"]], col = grey(0:100/100), legend = FALSE, main = names(dem)[i], axes = FALSE)
  plot(dem[[i]], col = terrain.colors(24, alpha = 0.50), add = TRUE)
  plot(contour_lines, add = TRUE, col = "black", reset = FALSE)
}
```

### Uso da terra e manejo do solo

Vamos retornar à imagem de satélite da área de estudo para identificar feições relacionadas ao uso da terra e
às práticas de manejo e conservação do solo que podem exercer algum controle sobre a distribuição espacial
das propriedades do solo. Adicionamos as curvas de nível para auxiliar na representação da forma do terreno e,
assim, identificar possíveis correlações entre o relevo e o uso da terra e as práticas de manejo e conservação 
do solo.

```{r}
mapview(contour_lines) +
  mapviewFarm()
```

__Exercício 2__ A imagem de satélite nos permite identificar uma série de feições espaciais relacionadas ao uso
da terra e às práticas de manejo e conservação do solo na área de estudo. Quais dessas feições você espera que
estejam relacionadas aos valores -- a serem observados -- das propriedades do solo que se pretende mapear e,
assim, estar determinando a sua distribuição espacial? Faça uma lista com, no mínimo, 10 itens.

1. ...
2. ...
3. ...
4. ...
5. ...
6. ...
7. ...
8. ...
9. ...
10. ...

A primeira feição espacial relacionada ao uso da terra identificada na área de estudo é a sua subdivisão em 
piquetes de pastoreio, indicando que os animais são conduzidos num sistema de pastoreio rotativo. O formato 
retangular dos piquetes não indica nenhuma relação entre a sua construção e as feições do terreno. Contudo, é
possível que diferentes práticas de manejo e conservação do solo sejam aplicadas em cada piquete, influenciando
assim a distribuição espacial das propriedades do solo.

Vamos carregar o arquivo vetorial `../data/vector/fields.shp` contendo os limites dos 26 piquetes de pastoreio 
e as quatro áreas de circulação interna dos animais. Em seguida, visualizamos os piquetes sobre a imagem de
satélite usando `mapview::mapview`. Adicionamos o limite da área de estudo para verificar a consistência 
espacial dos dados dos piquetes de pastoreio.

```{r}
fields <- read_sf("../data/vector/fields.shp")
mapview(fields) +
  mapviewFarm()
```

Para utilizar as informações sobre os piquetes nas etapas subsequentes, é preciso transformar os dados vetoriais
em dados matriciais. Vamos usar a função `raster::rasterize` para isso, usando o objeto `dem` como referência.

```{r}
fields %<>%
  rasterize(y = dem[["slope"]], field = "id")
names(fields) <- "fields"
mapview(fields) +
  mapviewFarm()
```

Uma segunda informação que pode importante para explicar a distribuição espacial das propriedades do solo é a
localização dos bebedouros. Isso porque os bebedouros, e seu entorno, são locais onde os animais costumam se
aglomerar periodicamente. Espera-se que pisoteio e a defecação e micção periódicos nesses locais altere, 
consideravelmente, as propriedades do solo, criando um ambiente diferenciado em relação ao restante da área de
estudo.

Vamos criar um vetor de pontos para indicar a localização dos tanques de água usando a função
`mapedit::drawFeatures`. Note que `mapedit::drawFeatures` retorna um objeto com coordenadas geográficas. Para
transformar as coordenadas para o sistema de referência de coodernadas EPSG:32722, usamos a função
`sf::st_transform`. Ainda, criamos uma coluna `id` para identificar cada um dos tanques (`dplyr::mutate`) e
descartamos as colunas criadas por `mapedit::drawFeatures` (`dplyr::select`). Salvamos o arquivo vetorial em 
disco -- `"../data/vector/water_tank.shp"` para facilitar o seu reúso.

```{r}
if (!file.exists("../data/vector/water_tank.shp")) {
  water_tank <- 
    mapview(farm, alpha.regions = 0.01, color = "red") %>% 
    drawFeatures() %>% 
    st_transform(crs = 32722) %>% 
    dplyr::mutate(id = 1:nrow(.)) %>% 
    dplyr::select(id)
  write_sf(water_tank, "../data/vector/water_tank.shp")
  mapview(water_tank) +
    mapviewFarm()
} else {
  water_tank <- read_sf("../data/vector/water_tank.shp")
  mapview(water_tank) +
    mapviewFarm()
}
```

Assim como fora feito com os polígonos que representam os piquetes de pastoreio, os dados sobre a localização 
dos bebedouros precisam ser transformados para o formato matricial. Como se trata de dados pontuais, que não
cobrem toda a área de estudo, uma solução é computar uma mapa de distâncias até os tanques de água. Isso é
razoável porque, em princípio, espera-se que o efeito do pisoteio, defecação e micção seja bastante localizado,
diminuindo a medida que nos afastamos dos bebedouros. Para calcular a distância até os bebedouros usamos a 
função `raster::distanceFromPoints` -- note que, primeiro, é preciso converter a classe do objeto `water_tank`
de `sf` para `SpatialPointsDataFrame`.

```{r}
water_tank_dist <-
  water_tank %>% 
  as_Spatial() %>% 
  distanceFromPoints(dem[["slope"]], .)
names(water_tank_dist) <- "water_tank_dist"
mapview(water_tank_dist) +
  mapview(water_tank, legend = FALSE) +
  mapviewFarm()
```

### Imagens de satélite e índices de vegetação

A análise da imagens de satélite da área de estudo mostra que a pastagem exibe alguma variação espacial na sua
coloração. Essa variação pode ser devida às propriedades do solo. Assim, as bandas de um sensor orbital e os
índices de vegetação podem ser úteis para explicar a variação espacial das propriedades do solo. Está disponível
o índice de vegetação por diferença normalizada (NDVI) da área de estudo em três datas: 22/04/2013, 25/01/2016 
e 20/04/2018. Vamos carregar os dados usando `raster::stack`.

```{r}
ndvi <- 
  c("2013_04_22", "2016_01_25", "2018_04_20") %>% 
  paste("../data/raster/ndvi_", ., ".tif", sep = "") %>% 
  stack() %T>% 
  plot(col = terrain.colors(100))
```

A distribuição espacial do NDVI parece bastante correlacionada com a disposição dos piquetes de pastoreio. 
Contudo, seria interessante conhecer a variação temporal do NDVI. Para isso, podemos calcular o seu desvio 
padrão em cada célula usando a função `raster::calc`. Quanto maior o desvio padrão, maior a variação temporal 
do NDVI. A magnitude da variação temporal do NDVI pode ajudar a identificar, por exemplo, áreas onde o solo 
impõe maiores restrições ao crescimento vegetativo ao longo dos anos como menor fertilidade, menor profundidade,
menor capacidade de retenção de água e elevada pedregosidade. Em locais como esses, a vegetação costuma ser mais
sensível às condições meteorológicas extremas, apresentando mais variação no NDVI. (Note que os dados estão
disponíveis para apenas três anos, o que pode não ser suficiente para representar a variação temporal do NDVI de
maneira precisa.)

```{r}
ndvi$ndvi_variation <-
  ndvi %>% 
  calc(sd) %T>% 
  plot()
```

### Propriedades do solo

Informações indiretas sobre as propriedades do solo também podem auxiliar no entendimento da variação espacial
das propriedades do solo que se pretende mapear. Uma delas é a condutividade elétrica aparente do solo. Vamos
carregar os dados de condutividade elétrica aparente -- `"../data/vector/ec.shp"` -- disponíveis para a área de
estudo. Note que os dados estão no formato vetorial (pontos) e precisam ser transformados para o formato
matricial via interpolação. Contudo, como a densidade de pontos é muito elevada, faremos uma filtragem dos dados
antes de proceder com a interpolação propriamente dita -- com `raster::rasterize`. Para isso, usaremos a mediana
dos valores observados dentro de cada célula de 30 m x 30 m, ignorando assim valores discrepantes. Em seguida, 
procedemos com a interpolação determinística usando as funções `fields::Tps` (_thin plate spline_) e
`raster::interpolate`.

```{r}
ec <- 
  read_sf("../data/vector/ec.shp") %>% 
  dplyr::select(CE37, CE75) %>% 
  rasterize(dem[["slope"]], fun = median) %>% 
  as("SpatialPointsDataFrame")
tps_ec37 <- Tps(ec@coords, ec$CE37)
tps_ec75 <- Tps(ec@coords, ec$CE75)
ec %<>% rasterize(dem[["slope"]])
ec <- ec[[c("CE37", "CE75")]]
ec[["CE37"]] <- interpolate(ec[["CE37"]], tps_ec37)
ec[["CE75"]] <- interpolate(ec[["CE75"]], tps_ec75)
plot(ec)
```

Para finalizar o processamento das covariáveis, vamos juntá-las em um único objeto `covar_data`. Os três 
objetos originais, `dem`, `ec` e `ndvi`, podem ser removidos do ambiete de trabalho e assim liberar espaço da
memória.

```{r}
covar_data <- 
  stack(dem, ec, ndvi, fields, water_tank_dist) %>% 
  dropLayer("hillshade")
rm(dem, ec, ndvi, fields, water_tank_dist)
```

A correlação linear entre as covariáveis pode ser observada usando a função `pedometrics::plotCor`. Note que, 
em geral, a correlação linear entre as covariáveis é pequena, o que indica que há pouca redundância nos dados.
A maior correlação é observada entre a curvatura geral e a curvatura de perfil -- r = 0.9. Isso significa que
um dos dois atributos do terreno pode ser descartado, sem prejuízo ao conjunto de dados.

```{r, fig.asp=1}
covar_data %>% 
  values() %>% 
  cor(use = "complete") %>% 
  round(2) %>% 
  plotCor(cex = 0.75)
```

## Amostragem do solo

Uma vez construída a base de dados espaciais da área de estudo, podemos proceder com a escolha dos locais de
observaçaõ do solo. Usaremos as covariáveis para escolher os locais de observação num processo de otimização
usando o pacote `spsann`. A localização das observações do solo será ecolhida de modo a cobrir a distribuição 
marginal de cada covariável usando a função `spsann::optimDIST`. Como o solo da área de estudo já foi observado,
nos limitaremos a escolher os locais de observação dentre as observações já existentes.

Os dados do solo estão numa planilha no Google Drive (veja abaixo a chave de identificação da planilha),
organizados conforme os padrões do Repositório Brasileiro Livre para Dados Abertos do Solo
(http://coral.ufsm.br/febr/). Para descarrega-los, usaremos as funções `googlesheets::gs_key` e
`googlesheets::gs_read_csv`. Note que é preciso usar a função `readr::locale` para especificar que utilizamos a
vírgula como separador decimal. São duas planilhas, `observacao` e `camada`, que fundimos usando `merge` e, em
seguida, transformamos para a classe `sf` usando `sf::st_as_sf`.

```{r}
locale <- locale(decimal_mark = ",")
camada <- 
  "1VqP_W9rS4DJN3EwrGnkT_gFduMTwaupFgct-9OqK9WI" %>% 
  gs_key() %>% 
  gs_read_csv(ws = "camada", locale = locale, comment = "#metadado>", verbose = FALSE)
observacao <-
  "1VqP_W9rS4DJN3EwrGnkT_gFduMTwaupFgct-9OqK9WI" %>% 
  gs_key() %>% 
  gs_read_csv(ws = "observacao", locale = locale, comment = "#metadado>", verbose = FALSE)
soil_data <- 
  merge(observacao, camada, by = "observacao_id") %>% 
  st_as_sf(coords = c("coord_x", "coord_y"), crs = 32722) %T>% 
  print()
```

Vamos visualizar a distribuição espacial das observações do solo na área de estudo.

```{r}
mapviewFarm() +
  soil_data %>% dplyr::select(observacao_id) %>% mapview(homebutton = FALSE, layer.name = "ID")
```

O próximo passo consiste em amostrar os valores das cvariáveis nos locais de observação do solo. Para isso 
usamos `raster::extract`. Em seguida, especificamos as covariáveis de tipo contínuo e categórico. Nesse estudo,
temos apenas uma covariável categórica, especificamente, aquela que identifica os piquetes de pastoreio. Para
isso usamos `dplyr::mutate`.

```{r}
soil_data %<>% cbind(., extract(covar_data, .))
soil_data %<>% 
  mutate(fields = as.factor(fields))
```

Agora podemos proceder com a otimização da configuração amostral usando `spsann::optimDIST` e os valores das 
covariáveis nas observações existentes.

```{r}
if (!file.exists("../data/r/optimization.rda")) {
  colNames <- function (x, col.names) {
    colnames(x) <- col.names
    as.matrix(x)
  }
bb <- soil_data %>% st_bbox()
schedulle <- spsann::scheduleSPSANN(chains = 500, initial.temperature = 2, cellsize = 0.1)
set.seed(1984)
soil_data_100 <-
  spsann::optimDIST(
    points = 100, 
    candi = 
      soil_data %>% 
      dplyr::filter(camada_id == 1) %>% 
      st_coordinates(soil_data) %>% 
      colNames(c("x", "y")), 
    covars = 
      soil_data %>% 
      dplyr::filter(camada_id == 1) %>% 
      dplyr::select(
        slope, plan_curvature, profile_curvature, twi, catchment_area, catchment_slope, ndvi_2013_04_22,
        ndvi_2016_01_25, ndvi_2018_04_20, ndvi_variation, CE37, CE75, fields, water_tank_dist, elevation) %>%
      st_set_geometry(NULL),
    use.coords = TRUE, schedule = schedulle, plotit = TRUE, track = TRUE, boundary = as_Spatial(farm))
save(soil_data_100, file = "../data/r/optimization.rda")
} else {
  load("../data/r/optimization.rda")
}
```

Depois da otimização, precisamos processar os dados.

```{r}
tmp_id <- 
  soil_data %>% 
  st_set_geometry(NULL) %>%
  dplyr::filter(camada_id == 1) %>% 
  dplyr::select(observacao_id) %>% 
  .[soil_data_100$points$id, ]
soil_data_100 <-
  soil_data %>% 
  dplyr::filter(observacao_id %in% tmp_id)
rm(tmp_id)
mapviewFarm() +
  mapview(soil_data_100)
```

## Calibração do modelo

```{r}
f <- carbono_xxx_xxx_xxx ~ coords.x1 + coords.x2 + slope + plan_curvature + profile_curvature + twi + catchment_area + catchment_slope + elevation + CE37 + CE75 + ndvi_2013_04_22 + ndvi_2016_01_25 + ndvi_2018_04_20 + ndvi_variation + fields + water_tank_dist + camada_id
```

```{r}
fit_rf_100 <- 
  soil_data_100 %>% 
  as_Spatial() %>% 
  as.data.frame() %>% 
  caret::train(
    f, data = ., na.action = na.omit, importance = "impurity",
    method = "ranger", trControl = caret::trainControl(method = "LOOCV")) %T>%
  print()
```

```{r, fig.asp=1}
par(mar = c(5, 8, 4, 2) + 0.1)
ranger::importance(fit_rf_100$finalModel) %>% 
  sort() %>% 
  barplot(horiz = TRUE, las = 1, col = "firebrick", cex.names = 0.75)
grid()
```

## Predição espacial

```{r}
pred_val <-
  soil_data %>% 
  dplyr::filter(!observacao_id %in% soil_data_100$observacao_id & camada_id == 1) %>% 
  predict(fit_rf_100, .)
soil_data %>% 
  dplyr::filter(!observacao_id %in% soil_data_100$observacao_id & camada_id == 1) %>% 
  dplyr::select(carbono_xxx_xxx_xxx) %>% 
  mutate(
    error = pred_val - carbono_xxx_xxx_xxx,
    residual = mean(carbono_xxx_xxx_xxx) - carbono_xxx_xxx_xxx,
    se = error^2,
    sr = residual^2) %>% 
  summarise(
    sse = sum(se),
    ssr = sum(sr),
    r2 = 1 - sse/ssr)
```

```{r}
covar_data$camada_id <- 1
covar_data$coords.x1 <- xFromCell(covar_data, 1:ncell(covar_data))
covar_data$coords.x2 <- yFromCell(covar_data, 1:ncell(covar_data))
```

```{r}
pred_100 <- 
  covar_data %>% 
  predict(fit_rf_100, factors = list(fields = levels(soil_data$fields)))
mapview(pred_100) + 
  soil_data_100 %>% dplyr::filter(camada_id == 1) %>% dplyr::select("carbono_xxx_xxx_xxx") %>% mapview() +
  mapview(contour_lines)
```


```{r}
xy <-
  soil_data %>% 
  dplyr::filter(!observacao_id %in% soil_data_100$observacao_id & camada_id == 1) %>% 
  st_coordinates()
res <- 
  pred_val -
  soil_data %>% 
  dplyr::filter(!observacao_id %in% soil_data_100$observacao_id & camada_id == 1) %>% 
  dplyr::select(carbono_xxx_xxx_xxx) %>% 
  st_drop_geometry()
plotESDA(z = res$carbono_xxx_xxx_xxx, lat = xy[, "Y"], lon = xy[, "X"])
```

```{r}
res <-
  soil_data %>% 
  mutate(
    pred = fit_rf_100$finalModel$predictions, 
    res = pred - carbono_xxx_xxx_xxx) %>% 
  filter(camada_id == 1)
xy <-
  soil_data %>% 
  filter(camada_id == 1) %>% 
  st_coordinates()
plotESDA(z = res$res, lat = xy[, "Y"], lon = xy[, "X"])
```

