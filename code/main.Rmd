---
title: "Digital soil mapping for precision agriculture"
subtitle: "FEAGRI-UNICAMP Workshop"
author: "Alessandro Samuel-Rosa"
date: "25 January 2019"
output: bookdown::html_document2
lang: pt
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(magrittr)
library(dplyr)
library(sf)
library(raster)
library(mapview)
library(RSAGA)
```

Este estudo tem como objetivo realizar o mapeamento de uma série de propriedades do solo em uma fazenda de 
produção de bovinos e corte no município de Caiuá, no oeste do estado de São Paulo. Dentre as propriedades do 
solo estão: conteúdo de fósforo e bases trocáveis, capacidade de troca de cátions e saturação por bases, 
conteúdo de micronutrientes, pH e acidez potencial, conteúdo de carbono orgânico, e distribuição do tamanho de
partículas.

# Material e Métodos

## Área de estudo

O primeiro passo consiste em fazer um levantamento das informações disponíveis sobre a área de estudo. Essas 
informações incluem dados espacialmente exaustivos, como imagens de satélite e índices de vegetação, modelos
digitais de elevação e atributos de terreno, mapas pedológicos e geológicos, entre outros. Também incluem 
informações históricas sobre o uso da terra e as práticas de manejo e conservação do solo.

Vamos iniciar visualizando a área de estudo sobre uma imagem de satélite da coleção pública da ESRI. Para isso,
carregamos o arquivo vetorial contendo o limite da área de estudo, `"../data/vector/farm.shp"`, usando a função 
`sf::read_sf`. Em seguida, criamos uma figura responsiva usando a função `mapview::mapview`.

```{r}
farm <- read_sf("../data/vector/farm.shp")
mapview(farm, color = "red", alpha.regions = 0.01, map.types = "Esri.WorldImagery", legend = F)
```

### Relevo

A imagem acima mostra que a área de estudo é cortada por inúmeros terraços, estruturas construídas para reduzir
a energia cinética da água da chuva escoando na superfície do solo e, assim, reduzir a erosão do solo. Também
observamos algumas escavações para coleta da enxurrada em pontos de convergência do terreno. Isso significa que
o relevo pode exercer um controle importante da distribuição espacial das propriedades do solo.

Vamos analisar mais de perto o relevo da área de estudo utilizando o modelo digital de elevação (MDE). Para 
isso, primeiro calculamos o sombreamento do relevo usando `sf::gdal_utils`. Em seguida, carregamos os dois
arquivos, `"../data/raster/elevation.tif"` e `"../data/raster/hillshade.tif"`, usando `raster::stack`, para 
então gerar uma imagem com as duas camadas são sobrepostas, dando a impressão visual da forma do terreno (3d).
Para auxiliar, adicionamos curvas de nível geradas com a função `raster::rasterToContour`. Na imagem, as partes
mais baixas do terreno são mostradas em azul.

```{r}
gdal_utils(
  util = "demprocessing", source = "../data/raster/elevation.tif", destination = "../data/raster/hillshade.tif",
  processing = "hillshade")
dem <- stack("../data/raster/elevation.tif", "../data/raster/hillshade.tif")
contour_lines <- dem[["elevation"]] %>% rasterToContour() %>% st_as_sf()
plot(dem[["hillshade"]], col = grey(0:100/100), legend = FALSE)
plot(dem[["elevation"]], col = topo.colors(24, alpha = 0.50), add = TRUE)
plot(contour_lines, add = TRUE, col = "black")
```

__Exercício 1__ A imagem acima mostra a configuração do terreno na área de estudo. Você espera que o terreno
esteja relacionado à distribuição espacial das propriedades do solo que se pretende mapear? De que maneira se 
daria essa relação? Quais atributos de terreno podem ser úteis para descrever o efeito do terreno sobre a
distribuição espacial das propriedades do solo? Faça uma lista com, no mínimo, cinco atributos de terreno.

1. ...
2. ...
3. ...
4. ...
5. ...

Atributos de terreno podem ser computados usando o SAGA GIS. Por exemplo, `RSAGA::rsaga.slope.asp.curv` calcula
alguns atributos locais do terreno, como a declividade e a curvatura do terreno. Alguns atributos regionais do
terreno, como a área de captação e o índice de umidade topográfica, podem ser calculados usando 
`RSAGA::rsaga.wetness.index`. Note que o formato de arquivo matricial do SAGA GIS é SGRD -- para escrita -- e
SDAT -- para leitura.

```{r}
rsaga.slope.asp.curv(
  in.dem = "../data/raster/elevation.tif",
  out.slope = "../data/raster/slope.sgrd",
  out.cgene = "../data/raster/general_curvature.sgrd",
  out.cplan = "../data/raster/plan_curvature.sgrd",
  out.cprof = "../data/raster/profile_curvature.sgrd",
  unit.slope = "percent")
rsaga.wetness.index(
  in.dem = "../data/raster/elevation.tif",
  out.wetness.index = "../data/raster/twi.sgrd", 
  out.carea = "../data/raster/catchment_area.sgrd", 
  out.cslope = "../data/raster/catchment_slope.sgrd",
  area.type = "absolute")
```

Em seguida carregamos os atributos de terreno para dentro do objeto `dem` usando `raster::stack`. Calculamos o
logaritmo da área de captação para transformar os dados para uma escala mais estreita e interpretável. Ainda,
transformamos os valores de declividade da área de captação de radianos para percentagem.

```{r}
dem <-
  stack(
    c("../data/raster/slope.sdat",
    "../data/raster/general_curvature.sdat",
    "../data/raster/plan_curvature.sdat", 
    "../data/raster/profile_curvature.sdat",
    "../data/raster/twi.sdat", 
    "../data/raster/catchment_area.sdat",
    "../data/raster/catchment_slope.sdat")) %>% 
  stack(dem)
dem[["catchment_area"]] <- log1p(dem[["catchment_area"]])
dem[["catchment_slope"]] <- tan(dem[["catchment_slope"]]) * 100
```

Depois de processados, podemos visualizar os atributos de terreno usando o sombreamento e as curvas de nível 
para auxiliar na sua interpretação.

```{r}
par(mfrow = c(3, 3))
for (i in 9:1) {
  plot(dem[["hillshade"]], col = grey(0:100/100), legend = FALSE, main = names(dem)[i])
  plot(dem[[i]], col = terrain.colors(24, alpha = 0.50), add = TRUE)
  plot(contour_lines, add = TRUE, col = "black", reset = FALSE)
}
```

### Uso da terra e manejo do solo

Vamos retornar à imagem de satélite da área de estudo.

```{r}
farm <- read_sf("../data/vector/farm.shp")
mapview(farm, color = "red", alpha.regions = 0.01, map.types = "Esri.WorldImagery", legend = F)
```

__Exercício 2__ A imagem de satélite nos permite identificar uma série de feições espaciais na área de
estudo. Quais dessas feições você espera que estejam relacionadas aos valores -- a serem observados -- das
propriedades do solo que se pretende mapear e, assim, estar determinando a sua distribuição espacial? Faça uma 
lista com, no mínimo, 10 itens.

1. ...
2. ...
3. ...
4. ...
5. ...
6. ...
7. ...
8. ...
9. ...
10. ...

## Soil data

```{r, message=FALSE, warning=FALSE}
# Download data
locale <- readr::locale(decimal_mark = ",")
camada <- 
  "1VqP_W9rS4DJN3EwrGnkT_gFduMTwaupFgct-9OqK9WI" %>% 
  googlesheets::gs_key() %>% 
  googlesheets::gs_read_csv(ws = "camada", locale = locale, comment = "#metadado>", verbose = FALSE)
observacao <-
  "1VqP_W9rS4DJN3EwrGnkT_gFduMTwaupFgct-9OqK9WI" %>% 
  googlesheets::gs_key() %>% 
  googlesheets::gs_read_csv(ws = "observacao", locale = locale, comment = "#metadado>", verbose = FALSE)
soil_data <- 
  merge(observacao, camada, by = "observacao_id") %>% 
  sf::st_as_sf(coords = c("coord_x", "coord_y"), crs = 32722) %T>% 
  print()
```

```{r}
study_area %>% 
  mapview::mapview(map.types = "Esri.WorldImagery", color = "red", alpha.regions = 0.01, legend = FALSE) +
  dplyr::select(soil_data, observacao_id) %>% mapview::mapview(homebutton = FALSE, layer.name = "ID")
```

## Covariates

```{r}
mapviewRaster(covar_data[[1:7]]) +
  mapview::mapview(study_area, legend = FALSE, alpha.regions = 0.01, color = "red", homebutton = FALSE)
```

Create a terrain attribute to depict the upslope distance from source cells.

```{r}
if (file.exists("../data/vector/seeds.shp")) {
  seeds <- sf::read_sf("../data/vector/seeds.shp")
  mapview::mapview(seeds["id"], map.types = "Esri.WorldImagery")
} else {
  seeds <- 
    mapview::mapview(study_area, alpha.regions = 0.01, color = "red", map.types = "Esri.WorldImagery") %>% 
    mapedit::drawFeatures() %>% 
    sf::st_transform(crs = 32722)
  seeds$id <- 1
  sf::write_sf(seeds, "../data/vector/seeds.shp")
  mapview::mapview(seeds["id"], map.types = "Esri.WorldImagery")
}
```

```{r}
# Shapes to Grid
# RSAGA::rsaga.get.libraries()
# RSAGA::rsaga.get.lib.modules("grid_gridding")
RSAGA::rsaga.geoprocessor(lib = "grid_gridding", module = 0, param = list(
  INPUT = "../data/vector/seeds.shp",
  TARGET_DEFINITION = 1,
  TARGET_TEMPLATE = "../data/raster/slope.sgrd",
  GRID = "../data/raster/seeds_grid.sgrd"))
# Flow Path Length (Deterministic 8)
# RSAGA::rsaga.get.libraries()
# RSAGA::rsaga.get.lib.modules("ta_hydrology")
RSAGA::rsaga.geoprocessor(lib = "ta_hydrology", module = 6, param = list(
  ELEVATION = "../data/raster/dem_30m.tif",
  SEED = "../data/raster/seeds_grid.sgrd",
  LENGTH = "../data/raster/flow_path_length.sgrd",
  SEEDS_ONLY = 1,
  METHOD = 0
))
flow_length <- raster::raster("../data/raster/flow_path_length.sdat")
raster::crs(flow_length) <- sf::st_crs(covar_data)$proj4string
mapview::mapview(study_area, map.types = "Esri.WorldImagery", color = "red", alpha.region = 0.01) +
  mapview::mapview(flow_length) +
  mapview::mapview(seeds)
```

```{r}
# Proximity Grid
# RSAGA::rsaga.get.libraries()
# RSAGA::rsaga.get.lib.modules("grid_tools")
RSAGA::rsaga.geoprocessor(lib = "grid_tools", module = 26, param = list(
  FEATURES = "../data/raster/seeds_grid.sgrd",
  DISTANCE = "../data/raster/seeds_distance.sgrd"
))
seeds_dist <- raster::raster("../data/raster/seeds_distance.sdat")
mapview::mapview(study_area, map.types = "Esri.WorldImagery", color = "red", alpha.region = 0.01) +
  mapview::mapview(seeds_dist) +
  mapview::mapview(seeds)
```

```{r}
flow_length[] <- flow_length[] / max(flow_length[], na.rm = TRUE)
flow_length[][is.na(flow_length[])] <- 1
seeds_dist_plus <- seeds_dist * flow_length
names(seeds_dist_plus) <- "seeds_dist_plus"
mapview::mapview(study_area, map.types = "Esri.WorldImagery", color = "red", alpha.region = 0.01) +
  mapview::mapview(seeds_dist_plus, col.regions = terrain.colors(800) %>% rev(), alpha.region = 1) +
  mapview::mapview(seeds)
```

```{r}
covar_data %<>%  raster::stack(seeds_dist_plus)
```

The correlation between covariates.

```{r}
covar_data[] %>% 
  cor(use = "complete") %>% 
  round(2) %>% 
  pedometrics::plotCor()
```

### Other covariares

```{r}
fields <- 
  sf::read_sf("../data/vector/fields.shp") %>% 
  sf::st_transform(crs = 32722)
fields$id <- 1:nrow(fields)
mapview::mapview(fields, map.types = "Esri.WorldImagery", legend = FALSE) +
  mapview::mapview(soil_data["observacao_id"], legend = FALSE) +
  mapview::mapview(study_area, legend = FALSE, alpha.regions = 0.01, color = "red", homebutton = FALSE)
```

## Modelling

Sample covariates at the location of sampling points.

```{r}
soil_data %<>% cbind(., raster::extract(covar_data, .))
soil_data$fields <- raster::extract(sf::as_Spatial(fields), sf::as_Spatial(soil_data))[, "id"]
```

```{r}
f <- fosforo_resina ~ slope + general_curvature + plan_curvature + profile_curvature + twi + catch_area + catch_slope + ndvi_2013_04_22 + ndvi_2016_01_25 + ndvi_2018_04_20 + ec + dem_30m + camada_id + seeds_dist_plus

fit <- 
  soil_data %>% 
  caret::train(
    f, data = ., na.action = na.omit,
    method = "ranger", tuneGrid = data.frame(mtry = 4, splitrule = "variance", min.node.size = 5),
    trControl = caret::trainControl(method = "LOOCV")) %T>%
  print()
  caret::getModelInfo("rf")
```

```{r}
soil_data %>% 
  dplyr::select(areia_xxx_xxx_xxx) %>% 
  dplyr::filter(areia_xxx_xxx_xxx > 890) %>%
  mapview::mapview(map.types = "Esri.WorldImagery") + 
  mapview::mapview(study_area, legend = FALSE, alpha.regions = 0.01, color = "red", homebutton = FALSE)
```



```{r}
covar_data$camada_id <- 1
soil_data$fosforo_resina_log <- log1p(soil_data$fosforo_resina)
predictions <- raster::predict(covar_data, fit)
mapviewRaster(predictions) + 
  mapview::mapview(soil_data[soil_data$camada_id == 1, "fosforo_resina"], legend = FALSE)
```

