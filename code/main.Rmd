---
title: "Mapeamento digital do solo para agricultura de precisão"
subtitle: "FEAGRI-UNICAMP"
author: "Alessandro Samuel-Rosa"
date: "25 e 26 de janeiro de 2019"
output: bookdown::html_document2
lang: pt
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(magrittr)
library(dplyr)
library(sf)
library(raster)
library(mapview)
mapviewOptions(basemaps = "Esri.WorldImagery")
library(RSAGA)
library(mapedit)
```

Este estudo tem como objetivo realizar o mapeamento de uma série de propriedades do solo em uma fazenda de 
produção de bovinos de corte no município de Caiuá, no oeste do estado de São Paulo. Dentre as propriedades do 
solo estão: conteúdo de fósforo e bases trocáveis, capacidade de troca de cátions e saturação por bases, 
conteúdo de micronutrientes, pH e acidez potencial, conteúdo de carbono orgânico, e distribuição do tamanho de
partículas.

# Material e Métodos

## Área de estudo

O primeiro passo consiste em fazer um levantamento das informações disponíveis sobre a área de estudo. Essas 
informações incluem dados espacialmente exaustivos, como imagens de satélite e índices de vegetação, modelos
digitais de elevação e atributos de terreno, mapas pedológicos e geológicos, entre outros. Também incluem 
informações históricas sobre o uso da terra e as práticas de manejo e conservação do solo.

Vamos iniciar visualizando a área de estudo sobre uma imagem de satélite da coleção pública da ESRI. Para isso,
carregamos o arquivo vetorial contendo o limite da área de estudo, `"../data/vector/farm.shp"`, usando a função 
`sf::read_sf`. Em seguida, criamos uma figura responsiva usando a função `mapview::mapview`.

```{r}
farm <- read_sf("../data/vector/farm.shp")
mapviewFarm <- 
  function () {
    mapview(farm, color = "red", alpha.regions = 0.01, legend = FALSE)
  }
mapviewFarm()
```

### Relevo

A imagem acima mostra que a área de estudo é cortada por inúmeros terraços, estruturas construídas para reduzir
a energia cinética da água da chuva escoando na superfície do solo e, assim, reduzir a erosão do solo. Também
observamos algumas escavações para coleta da enxurrada em pontos de convergência do terreno. Como os fluxos 
hídricos na paisagem influenciam a formação do solo, espera-se que o relevo da área de estudo exerça algum
controle sobre a distribuição espacial das propriedades do solo.

Vamos analisar mais de perto o relevo da área de estudo utilizando o modelo digital de elevação (MDE). Para 
isso, primeiro calculamos o sombreamento do relevo usando `sf::gdal_utils`. Em seguida, carregamos os dois
arquivos, `"../data/raster/elevation.tif"` e `"../data/raster/hillshade.tif"`, usando `raster::stack`, para 
então gerar uma imagem com as duas camadas sobrepostas, dando assim a impressão visual do formato 
tridimensional do terreno. Para auxiliar, adicionamos curvas de nível geradas com a função 
`raster::rasterToContour`.

```{r}
gdal_utils(
  util = "demprocessing", source = "../data/raster/elevation.tif", destination = "../data/raster/hillshade.tif",
  processing = "hillshade")
dem <- stack("../data/raster/elevation.tif", "../data/raster/hillshade.tif")
contour_lines <- dem[["elevation"]] %>% rasterToContour() %>% st_as_sf()
plot(dem[["hillshade"]], col = grey(0:100/100), legend = FALSE)
plot(dem[["elevation"]], col = topo.colors(24, alpha = 0.50), add = TRUE)
plot(contour_lines, add = TRUE, col = "black")
```

__Exercício 1__ A imagem acima mostra a configuração do terreno na área de estudo. Você espera que o terreno
esteja relacionado à distribuição espacial das propriedades do solo que se pretende mapear? De que maneira se 
daria essa relação? Quais atributos de terreno podem ser úteis para descrever o efeito do terreno sobre a
distribuição espacial das propriedades do solo? Faça uma lista com, no mínimo, cinco atributos de terreno.

1. ...
2. ...
3. ...
4. ...
5. ...

Atributos de terreno podem ser computados usando o SAGA GIS. Por exemplo, `RSAGA::rsaga.slope.asp.curv` calcula
alguns atributos locais do terreno, como a declividade e a curvatura do terreno. Alguns atributos regionais do
terreno, como a área de captação e o índice de umidade topográfica, podem ser calculados usando 
`RSAGA::rsaga.wetness.index`. Note que o formato de arquivo matricial do SAGA GIS é SGRD -- para escrita -- e
SDAT -- para leitura.

```{r}
rsaga.slope.asp.curv(
  in.dem = "../data/raster/elevation.tif",
  out.slope = "../data/raster/slope.sgrd",
  out.cgene = "../data/raster/general_curvature.sgrd",
  out.cplan = "../data/raster/plan_curvature.sgrd",
  out.cprof = "../data/raster/profile_curvature.sgrd",
  unit.slope = "percent")
rsaga.wetness.index(
  in.dem = "../data/raster/elevation.tif",
  out.wetness.index = "../data/raster/twi.sgrd", 
  out.carea = "../data/raster/catchment_area.sgrd", 
  out.cslope = "../data/raster/catchment_slope.sgrd",
  area.type = "absolute")
```

Em seguida carregamos os atributos de terreno computados usando o SAGA GIS para dentro do objeto `dem` -- 
criado acima -- usando `raster::stack`. Calculamos o logaritmo da área de captação para transformar os dados 
para uma escala mais estreita e interpretável. Ainda, transformamos os valores de declividade da área de 
captação de radianos para porcentagem.

```{r}
dem <-
  stack(
    c("../data/raster/slope.sdat",
    "../data/raster/general_curvature.sdat",
    "../data/raster/plan_curvature.sdat", 
    "../data/raster/profile_curvature.sdat",
    "../data/raster/twi.sdat", 
    "../data/raster/catchment_area.sdat",
    "../data/raster/catchment_slope.sdat")) %>% 
  stack(dem)
dem[["catchment_area"]] <- log1p(dem[["catchment_area"]])
dem[["catchment_slope"]] <- tan(dem[["catchment_slope"]]) * 100
```

Depois de processados, podemos visualizar os atributos do terreno usando o sombreamento e as curvas de nível 
para auxiliar na sua interpretação. Como são vários os atributos do terreno, precisamos iterar sobre a função
`plot` tantas vezes quantos forem os atributos do terreno usando a função `for`.

```{r}
nr <- nlayers(dem) %>% sqrt() %>% ceiling()
nc <- nlayers(dem) / nr
par(mfrow = c(nr, nc))
for (i in nlayers(dem):1) {
  plot(dem[["hillshade"]], col = grey(0:100/100), legend = FALSE, main = names(dem)[i], axes = FALSE)
  plot(dem[[i]], col = terrain.colors(24, alpha = 0.50), add = TRUE)
  plot(contour_lines, add = TRUE, col = "black", reset = FALSE)
}
```

### Uso da terra e manejo do solo

Vamos retornar à imagem de satélite da área de estudo para identificar feições relacionadas ao uso da terra e
às práticas de manejo e conservação do solo que podem exercer algum controle sobre a distribuição espacial
das propriedades do solo. Adicionamos as curvas de nível para auxiliar na representação da forma do terreno e,
assim, identificar possíveis correlações entre o relevo e o uso da terra e as práticas de manejo e conservação 
do solo.

```{r}
mapview(contour_lines) +
  mapviewFarm()
```

__Exercício 2__ A imagem de satélite nos permite identificar uma série de feições espaciais relacionadas ao uso
da terra e às práticas de manejo e conservação do solo na área de estudo. Quais dessas feições você espera que
estejam relacionadas aos valores -- a serem observados -- das propriedades do solo que se pretende mapear e,
assim, estar determinando a sua distribuição espacial? Faça uma lista com, no mínimo, 10 itens.

1. ...
2. ...
3. ...
4. ...
5. ...
6. ...
7. ...
8. ...
9. ...
10. ...

A primeira feição espacial relacionada ao uso da terra identificada na área de estudo é a sua subdivisão em 
piquetes de pastoreio, indicando que os animais são conduzidos num sistema de pastoreio rotativo. O formato 
retangular dos piquetes não indica nenhuma relação entre a sua construção e as feições do terreno. Contudo, é
possível que diferentes práticas de manejo e conservação do solo sejam aplicadas em cada piquete, influenciando
assim a distribuição espacial das propriedades do solo.

Vamos carregar o arquivo vetorial `../data/vector/fields.shp` contendo os limites dos 27 piquetes de pastoreio.
Em seguida, visualizamos os piquetes sobre a imagem de satélite usando `mapview::mapview`. Adicionamos o limite
da área de estudo para verificar a consistência espacial dos dados dos piquetes de pastoreio.

```{r}
fields <- sf::read_sf("../data/vector/fields.shp")
mapview(fields) +
  mapviewFarm()
```

O primeiro detalhe que observamos é que o arquivo vetorial dos limites dos piquetes contém três área em branco.
Trata-se das áreas de circulação dos animais entre os piquetes, as quais contém bebedouros. Vamos adicionar 
três polígonos para representar cada uma dessas áreas. Para isso, usaremos a função `mapedit::editFeatures`. 
Note que `mapedit::editFeatures` cria algumas novas variáveis de identificação dos polígonos. Como nosso 
interesse é apenas na variável `id`, podemos descartar as demais usando `dplyr::select`. Note, também, que é 
preciso atualizar a variável `id`, adicionando valores aos três novos polígonos criados. Fazemos isso usando 
`dplyr::mutate`. Em seguida, salvamos em disco os novos dados como `"../data/vector/fields2.shp"` a fim de não
perdermos as edições realizadas em caso de reexecução do código fonte.

```{r}
if (nrow(fields) == 27 && !file.exists("../data/vector/fields2.shp")) {
  fields %<>% 
    editFeatures(map = m) %>% 
    st_transform(crs = 32722) %>% 
    dplyr::select(id) %>% 
    dplyr::mutate(id = 1:nrow(.))
  write_sf(fields, "../data/vector/fields2.shp")
} else if (file.exists("../data/vector/fields2.shp")) {
  fields <- read_sf("../data/vector/fields2.shp")
}
mapview(fields) +
  mapviewFarm()
```

Para utilizar as informações sobre os piquetes nas etapas subsequentes, é preciso transformar os dados vetoriais
em dados matriciais. Vamos usar a função `raster::rasterize` para isso, usando o objeto `dem` como referência.

```{r}
fields %<>%
  rasterize(y = dem, field = "id")
mapview(fields) +
  mapviewFarm()
```

Uma segunda informação que pode importante para explicar a distribuição espacial das propriedades do solo é a
localização dos bebedouros. Isso porque os bebedouros, e seu entorno, são locais onde os animais costumam se
aglomerar periodicamente. Espera-se que pisoteio e a defecação e micção periódicos nesses locais altere, 
consideravelmente, as propriedades do solo, criando um ambiente diferenciado em relação ao restante da área de
estudo.

Vamos criar um vetor de pontos para indicar a localização dos tanques de água usando a função
`mapedit::drawFeatures`. Note que `mapedit::drawFeatures` retorna um objeto com coordenadas geográficas. Para
transformar as coordenadas para o sistema de referência de coodernadas EPSG:32722, usamos a função
`sf::st_transform`. Ainda, criamos uma coluna `id` para identificar cada um dos tanques (`dplyr::mutate`) e
descartamos as colunas criadas por `mapedit::drawFeatures` (`dplyr::select`). Salvamos o arquivo vetorial em 
disco -- `"../data/vector/water_tank.shp"` para facilitar o seu reúso.

```{r}
if (!file.exists("../data/vector/water_tank.shp")) {
  water_tank <- 
    mapview(farm, alpha.regions = 0.01, color = "red") %>% 
    drawFeatures() %>% 
    st_transform(crs = 32722) %>% 
    dplyr::mutate(id = 1:nrow(.)) %>% 
    dplyr::select(id)
  write_sf(water_tank, "../data/vector/water_tank.shp")
  mapview(water_tank) +
    mapviewFarm()
} else {
  water_tank <- read_sf("../data/vector/water_tank.shp")
  mapview(water_tank) +
    mapviewFarm()
}
```

Assim como fora feito com os polígonos que representam os piquetes de pastoreio, os dados sobre a localização 
dos bebedouros precisam ser transformados para o formato matricial. Como se trata de dados pontuais, que não
cobrem toda a área de estudo, uma solução é computar uma mapa de distâncias até os tanques de água. Isso é
razoável porque, em princípio, espera-se que o efeito do pisoteio, defecação e micção seja bastante localizado,
diminuindo a medida que nos afastamos dos bebedouros. Para calcular a distância até os bebedouros usamos a 
função `raster::distanceFromPoints` -- note que, primeiro, é preciso converter a classe do objeto `water_tank`
de `sf` para `SpatialPointsDataFrame`.

```{r}
water_tank_dist <-
  water_tank %>% 
  as_Spatial() %>% 
  distanceFromPoints(dem[["slope"]], .)
mapview(water_tank_dist) +
  mapview(water_tank, legend = FALSE) +
  mapviewFarm()
```


## Soil data

```{r, message=FALSE, warning=FALSE}
# Download data
locale <- readr::locale(decimal_mark = ",")
camada <- 
  "1VqP_W9rS4DJN3EwrGnkT_gFduMTwaupFgct-9OqK9WI" %>% 
  googlesheets::gs_key() %>% 
  googlesheets::gs_read_csv(ws = "camada", locale = locale, comment = "#metadado>", verbose = FALSE)
observacao <-
  "1VqP_W9rS4DJN3EwrGnkT_gFduMTwaupFgct-9OqK9WI" %>% 
  googlesheets::gs_key() %>% 
  googlesheets::gs_read_csv(ws = "observacao", locale = locale, comment = "#metadado>", verbose = FALSE)
soil_data <- 
  merge(observacao, camada, by = "observacao_id") %>% 
  sf::st_as_sf(coords = c("coord_x", "coord_y"), crs = 32722) %T>% 
  print()
```

```{r}
study_area %>% 
  mapview::mapview(map.types = "Esri.WorldImagery", color = "red", alpha.regions = 0.01, legend = FALSE) +
  dplyr::select(soil_data, observacao_id) %>% mapview::mapview(homebutton = FALSE, layer.name = "ID")
```



```{r}
# Shapes to Grid
# RSAGA::rsaga.get.libraries()
# RSAGA::rsaga.get.lib.modules("grid_gridding")
RSAGA::rsaga.geoprocessor(lib = "grid_gridding", module = 0, param = list(
  INPUT = "../data/vector/seeds.shp",
  TARGET_DEFINITION = 1,
  TARGET_TEMPLATE = "../data/raster/slope.sgrd",
  GRID = "../data/raster/seeds_grid.sgrd"))
# Flow Path Length (Deterministic 8)
# RSAGA::rsaga.get.libraries()
# RSAGA::rsaga.get.lib.modules("ta_hydrology")
RSAGA::rsaga.geoprocessor(lib = "ta_hydrology", module = 6, param = list(
  ELEVATION = "../data/raster/dem_30m.tif",
  SEED = "../data/raster/seeds_grid.sgrd",
  LENGTH = "../data/raster/flow_path_length.sgrd",
  SEEDS_ONLY = 1,
  METHOD = 0
))
flow_length <- raster::raster("../data/raster/flow_path_length.sdat")
raster::crs(flow_length) <- sf::st_crs(covar_data)$proj4string
mapview::mapview(study_area, map.types = "Esri.WorldImagery", color = "red", alpha.region = 0.01) +
  mapview::mapview(flow_length) +
  mapview::mapview(seeds)
```

```{r}
# Proximity Grid
# RSAGA::rsaga.get.libraries()
# RSAGA::rsaga.get.lib.modules("grid_tools")
RSAGA::rsaga.geoprocessor(lib = "grid_tools", module = 26, param = list(
  FEATURES = "../data/raster/seeds_grid.sgrd",
  DISTANCE = "../data/raster/seeds_distance.sgrd"
))
seeds_dist <- raster::raster("../data/raster/seeds_distance.sdat")
mapview::mapview(study_area, map.types = "Esri.WorldImagery", color = "red", alpha.region = 0.01) +
  mapview::mapview(seeds_dist) +
  mapview::mapview(seeds)
```

```{r}
flow_length[] <- flow_length[] / max(flow_length[], na.rm = TRUE)
flow_length[][is.na(flow_length[])] <- 1
seeds_dist_plus <- seeds_dist * flow_length
names(seeds_dist_plus) <- "seeds_dist_plus"
mapview::mapview(study_area, map.types = "Esri.WorldImagery", color = "red", alpha.region = 0.01) +
  mapview::mapview(seeds_dist_plus, col.regions = terrain.colors(800) %>% rev(), alpha.region = 1) +
  mapview::mapview(seeds)
```

```{r}
covar_data %<>%  raster::stack(seeds_dist_plus)
```

The correlation between covariates.

```{r}
covar_data[] %>% 
  cor(use = "complete") %>% 
  round(2) %>% 
  pedometrics::plotCor()
```

## Modelling

Sample covariates at the location of sampling points.

```{r}
soil_data %<>% cbind(., raster::extract(covar_data, .))
soil_data$fields <- raster::extract(sf::as_Spatial(fields), sf::as_Spatial(soil_data))[, "id"]
```

```{r}
f <- fosforo_resina ~ slope + general_curvature + plan_curvature + profile_curvature + twi + catch_area + catch_slope + ndvi_2013_04_22 + ndvi_2016_01_25 + ndvi_2018_04_20 + ec + dem_30m + camada_id + seeds_dist_plus

fit <- 
  soil_data %>% 
  caret::train(
    f, data = ., na.action = na.omit,
    method = "ranger", tuneGrid = data.frame(mtry = 4, splitrule = "variance", min.node.size = 5),
    trControl = caret::trainControl(method = "LOOCV")) %T>%
  print()
  caret::getModelInfo("rf")
```

```{r}
soil_data %>% 
  dplyr::select(areia_xxx_xxx_xxx) %>% 
  dplyr::filter(areia_xxx_xxx_xxx > 890) %>%
  mapview::mapview(map.types = "Esri.WorldImagery") + 
  mapview::mapview(study_area, legend = FALSE, alpha.regions = 0.01, color = "red", homebutton = FALSE)
```



```{r}
covar_data$camada_id <- 1
soil_data$fosforo_resina_log <- log1p(soil_data$fosforo_resina)
predictions <- raster::predict(covar_data, fit)
mapviewRaster(predictions) + 
  mapview::mapview(soil_data[soil_data$camada_id == 1, "fosforo_resina"], legend = FALSE)
```

